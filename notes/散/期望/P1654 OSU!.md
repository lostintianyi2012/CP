---
tags: Mathematical_expectation
type: solution
---
设 $Y_X$ 表示第 $X$ 个位置为 $1$，$N_X$ 表示第 $X$ 个位置非 $1$ 
只考虑前 $X$ 个位置
再设
$E(1|Y_X)=1$
$E(X)$ 表示 $X$ ==之前的一段连续极长子段长度期望==
$E(X^2)$ 表示 $X$ ==之前的一段连续极长子段长度的平方的期望==
$E(X^3)$ 表示 $X$ ==之前的一段连续极长子段长度的立方的期望==
那么有
$$
\begin{equation}
\begin{aligned}
E\bigg ((X+1)^3|Y_{X+1}\bigg)
&=E\bigg((X+1)^3\bigg)\times P(Y_{X+1})\\
&=E(X^3+3X^2+3X+1|Y_{X})\times P(Y_{X+1})\\
\end{aligned}
\end{equation}
$$
其中第二步可以由 $E(X^3)$ 的定义导出
继续分析有
$$
\begin{equation}
\begin{aligned}
原式
=&[E(X^3|Y_{X})+3E(X^2|Y_{X})+3E(X|Y_{X})+E(1|Y_X)]\\
&\times P(Y_{X+1})\\
\end{aligned}
\end{equation}
$$
其中，增量是
$$
[3E(X^2|Y_{X})+3E(X|Y_{X})+E(1|Y_X)]\times P(Y_{X+1})
$$
而
$$
E(X^3|Y_X)\times P(Y_{X+1})
$$
是原来部分的贡献

类似的可以算出 $E\big((X+1)^2|Y_{X+1}\big)、E\big((x+1)|Y_{X}\big)$
$$
\begin{equation}
\begin{aligned}
&E\big((X+1)^2|Y_{X+1}\big)=E(X^2|Y_{X})+2E(X|Y_{X})+E(1|Y_{X})\times P(Y_{X+1})\\
&E\big((X+1)|Y_{X}\big)=E(X|Y_X)+E(1|Y_X)\times P(Y_{X+1})
\end{aligned}
\end{equation}
$$
考虑统计答案：
由于只需要用到 $E(X)$ 和 $E(X^2)$ 来计算连续长度量对于期望的影响，所以可以更改 $E(X^3)$ 表示的内容来统计答案，这并不影响到增量的计算
现在令：$E(X^3)$ 表示前 $X$ 个位置所有连续极长子串的长度的立方之和的期望
那么统计 $E(X+1)$ 时
假设该点为 $1$，统计增量期望部分的部分不变
$$
[3E(X^2|Y_{X})+3E(X|Y_{X})+E(1|Y_X)]\times P(Y_{X+1})
$$
原来部分的贡献还是
$$
E(X^3)\times P(Y_{X+1})
$$
假设该点为 $0$，那么没有期望的增量，原来部分的贡献就是
$$
E(X^3)\times P(N_{X+1})
$$
合起来就是
$$
E((X+1)^3)=E(X^3)+[3E(X^2|Y_{X})+3E(X|Y_{X})+E(1|Y_X)]\times P(Y_{X+1})
$$
程序实现上相当简单
```cpp
#include <iostream>
#include <string.h>
#include <algorithm>

using namespace std;
const int N = 1e5 + 10;
//转移的时候自带了 |Y_X 的情况，所以可以全部略去，这对计算没有影响
double p[N], x1[N], x2[N], ans[N];
int n;

int main(){
	scanf("%d", &n);
	for(int i = 1; i <= n; i++)
		scanf("%lf", &p[i]);
	//把所有 X 都变成了 X-1，实际上刷表变填表也没有影响
	for(int i = 1; i <= n; i++){
		x1[i] = (x1[i-1] + 1) * p[i];
		x2[i] = (x2[i-1] + 2 * x1[i-1] + 1) * p[i];
		ans[i] = ans[i-1] + (3 * x2[i-1] + 3 * x1[i-1] + 1) * p[i];
	}
	printf("%.1lf\n", ans[n]);
	return 0;
}
```