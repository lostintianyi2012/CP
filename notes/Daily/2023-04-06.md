---
aliases: 2023-04-06
tag: Daily-note
date: 2023-04-06
---
## 待办事项
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 

## 学习内容

1. 
2. 
3. 
4. 

## 日记
~~差点违约~~
CF开了四题
## 做题记录

### CF1800G
给你一颗以 $1$ 为根的 $n$ 个节点的树，问这棵树是否存在一种安排子节点的方法使树是“对称的”

一眼秒了。树哈希板子，然而不会树哈希，考虑口胡一下哈希方法
不口胡了还是学一下树哈希。

细节怎么这么难写……
终于过了，中心对称的时候忘记一种哈希计数只能算一次了比较蠢
用了dls的树哈希
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <set>
#include <unordered_map>
#include <ctime>

using namespace std;
typedef unsigned long long ll;
const int N = 2e5 + 10;
const ll mod = 998244353;
int h[N], e[N << 1], ne[N << 1], idx;
ll hs[N];
int fa[N];
int size[N];
int n;

inline void add(int u, int v){
	e[idx] = v, ne[idx] = h[u], h[u] = idx++;
}

void clear(){
	memset(h, -1, (n + 2) * sizeof(int));
	memset(hs, 0, (n + 2) * sizeof(ll));
	memset(size, 0, (n + 2) * sizeof(int));
	idx = 0;
}

ll HFunction(ll x){
	return x * x * x * 1237123 + 19260817;
}

ll f(ll x){
	ll cur = HFunction(x & ((1ll << 31) - 1)) + HFunction((x >> 31) & 1);
	return cur;
}

void dfs(int u){
	size[u] = 1;
	for(int i = h[u]; ~i; i = ne[i]){
		int v = e[i];
		if(v == fa[u])
			continue;
		fa[v] = u;
		dfs(v);
		hs[u] += f(hs[v]);
		size[u] += size[v];
	}
	hs[u] += 1;
}

bool check_mirror(int u){
	if(size[u] == 1)
		return true;

	int count = 0, midtree;
	unordered_map<ll, int> hashmap;

	for(int i = h[u]; ~i; i = ne[i]){
		int v = e[i];
		if(v == fa[u])
			continue;
		hashmap[hs[v]] += 1;
	}
	unordered_map<ll, int> cnt2;

	for(int i = h[u]; ~i; i = ne[i]){
		int v = e[i];
		if(v == fa[u])
			continue;
		if((hashmap[hs[v]] & 1) && !cnt2[hs[v]]){
			count++;
			midtree = v;
			cnt2[hs[v]] += 1;
		}
	}
	if(count > 1)
		return false;
	else if(count == 1)
		return check_mirror(midtree);

	return true;
}

void solve(){
	cin >> n;
	for(int i = 1; i < n; i++){
		int u, v;
		cin >> u >> v;
		add(u, v), add(v, u);
	}
	dfs(1);
	
	bool ans = check_mirror(1);
	if(ans)
		cout << "YES\n";
	else
		cout << "NO\n";
}

int main(){
	memset(h, -1, sizeof(h));
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	int T;
	cin >> T;
	while(T--){
		clear();
		solve();
	}
	return 0;
}

```
### CF1801B
给你 $n$ 个二元组 $(a, b)$
你需要从中选出一些二元组，取其中的 $a$ 组成一个数集 $S_1$
对于其余的二元组，取其中的 $b$ 组成一个数集 $S_2$
最小化两个序列的极差

考虑枚举 $S_1$ 的最大值，假设当前的权值为 $x$
那么所有第一维权值 $>x$ 的都==不能选==
假设 $y$ 为这其中所有权值的最大值，假设 $y\ge x$ 那么第一维 $\le x$ 的选与不选都无所谓，因为这个时候假设第二维是 $\le y$ 的那么不会改变 $y$
如果第二维 $y < x$ 可以在前面的 $y$ 组成的集合中找到 $x$ 的前驱和后继更新答案
```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>
#include <set>

using namespace std;
typedef pair<int, int> pii;
const int N = 5e5 + 10;
const int inf = 0x3f3f3f3f;
pii a[N];
int suffix[N];
int n;

int ABS(int x){
	return x < 0 ? -x : x;
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	int T;
	cin >> T;
	while(T--){
		cin >> n;
		for(int i = 1; i <= n; i++)
			cin >> a[i].first >> a[i].second;
		sort(a + 1, a + 1 + n);

		suffix[n + 1] = -inf;
		for(int i = n; i >= 1; i--)
			suffix[i] = max(suffix[i + 1], a[i].second);
		
		int ans = inf;
		set<int> S;
		S.insert(inf), S.insert(-inf);

		for(int i = 1; i <= n; i++){
			int x = a[i].first;
			int y = suffix[i + 1];
			ans = min(ans, ABS(x - y));
			auto it = S.lower_bound(x);
			ans = min(ans, ABS(x - max(*it, y)));
			it = S.upper_bound(x);
			it--;
			ans = min(ans, ABS(x - max(*it, y)));
			S.insert(a[i].second);
		}
		cout << ans << '\n';
	}
	return 0;
}

```
### CF1801C
容易注意到遍历一个向量之后，如果最大值没有变化，那么这个向量相当于是无效的
所以就是让最大值更新尽可能多次，考虑按一个向量之内的最大值sort所有向量，按顺序遍历所有向量即可
容易注意到，交换两个向量一定更加不优
### CF1810E
