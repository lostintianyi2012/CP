---
aliases: 2023-04-17
tag: Daily-note
date: 2023-04-17
---
## 待办事项
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 

## 学习内容

1. 
2. 
3. 
4. 

## 日记
又是周一。
这周打算一边做CF的补题一边做计算几何，基本上就是用OI wiki上的和刘汝佳的书做
这周目标姑且是把平面几何部分过完，然后补完题的vp超过三场吧
## 做题记录
### CF1797 E.Li Hua and Array
给你一个长度为 $n$ 的序列，你需要支持两种操作
1. 给出 $l,r$, 令 $i\in [l, r]$ 中 $a_i:=\varphi(a_i)$
2. 给出 $l,r$, 每次可以选择一个 $x$ 令 $a_x:=\varphi(a_x)$ 找出令 $a_l=a_{l+1}=\cdots =a_r$ 的最小操作次数
$n,m\le 10^5,a_i\le 5\times 10^6$

记
$$
\varphi^k(x)=
\begin{cases}
x,&k=0\\
\varphi(\varphi^{k-1}(x)), &k\in\mathbb{N^+}
\end{cases}
$$
一个 $\varphi(x)$ 可能对应多个不同的 $x$，而对于每个 $x$ 所得 $\varphi(x)$ 是唯一的，考虑以 $1$ 为根，每个 $x$ 向 $\varphi(x)$ 连一条边，这样会得到一个树形的结构
那么，对于一组 $a_l,a_{l+1},\cdots, a_r$ 每次令 $a_x:=\varphi(a_x)$ 的操作相当于在树上跳父亲节点，使它们全部相同的次数就是它们的 LCA 到所有点距离之和

考虑线段树维护这个东西，用线段树维护区间节点的 LCA ,最小深度和答案，由于可以证明， $x$ 在经过不超过 $\log x$ 次 $x:=\varphi(x)$ 的操作之后会变为 $1$，直接暴力修改，如果区间全 $1$ 直接忽略的复杂度在均摊意义下是正确的，暴力即可
均摊分析一下，最多要进行 $O(n\log w)$ 次修改，每次修改要访问 $\log n$ 个子节点，再合并 $\log n$ 次信息，由于每次合并对树高为 $\log w$ 的树求 LCA 所以复杂度是 $O(n\log w \log n \log \log w)$
预处理复杂度是 $O(w \log w)$，每次需要 $O(\log n\log \log w)$ 的复杂度来回答询问
```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;
typedef long long ll;
const int N = 1e5 + 10, W = 5e6 + 10;
int prime[350000], phi[W], cnt;
bool not_prime[W];
int a[N];
int n, m;

void sieve()
{
    phi[1] = 1;
    for (int i = 2; i < W; i++) {
        if (!not_prime[i]) {
            phi[i] = i - 1;
            prime[++cnt] = i;
        }
        for (int j = 1; j <= cnt && i * prime[j] < W; j++) {
            not_prime[i * prime[j]] = true;
            if (i % prime[j]) {
                phi[i * prime[j]] = phi[i] * phi[prime[j]];
            } else {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
        }
    }
}

int fa[7][W], dep[W];
void tree()
{
    dep[1] = 1;
    for (int i = 0; i < 7; i++)
        fa[i][1] = 1;
    for (int i = 2; i < W; i++) {
        dep[i] = dep[phi[i]] + 1;
        fa[0][i] = phi[i];
        for (int j = 1; j < 7; j++)
            fa[j][i] = fa[j - 1][fa[j - 1][i]];
    }
}

int LCA(int u, int v)
{
    if (dep[u] < dep[v])
        swap(u, v);
    for (int i = 6; i >= 0; i--)
        if (dep[fa[i][u]] >= dep[v])
            u = fa[i][u];
    if (u == v)
        return u;
    for (int i = 6; i >= 0; i--)
        if (fa[i][u] != fa[i][v])
            u = fa[i][u], v = fa[i][v];
    return fa[0][u];
}

struct node {
    int l, r;
    int lca, ignore;
    ll ans;
} tr[N << 2];

void pushup(int u){
	node &ls = tr[u << 1], &rs = tr[u << 1 | 1];
	tr[u].lca = LCA(ls.lca, rs.lca);
	tr[u].ans = ls.ans + rs.ans
				+ (ls.r - ls.l + 1) * (dep[ls.lca] - dep[tr[u].lca])
				+ (rs.r - rs.l + 1) * (dep[rs.lca] - dep[tr[u].lca]);
	tr[u].ignore = ls.ignore & rs.ignore;
}

void build(int u, int l, int r)
{
	tr[u].l = l, tr[u].r = r;
	if(l == r){
		tr[u].lca = a[l];
		tr[u].ignore = a[l] == 1;
		tr[u].ans = 0;
		return;
	}
	int mid = l + r >> 1;
	build(u << 1, l, mid);
	build(u << 1 | 1, mid + 1, r);
	pushup(u);
}

void modify(int u, int l, int r)
{
	if(tr[u].ignore)
		return; 
	if(tr[u].l == tr[u].r){
		tr[u].lca = phi[tr[u].lca];
		tr[u].ignore = (tr[u].lca == 1);
		return ;
	}
	int mid = tr[u].l + tr[u].r >> 1;
	if(l <= mid)
		modify(u << 1, l, r);
	if(r > mid)
		modify(u << 1 | 1, l, r);
	pushup(u);
}

int query_lca(int u, int l, int r)
{
	if(l <= tr[u].l && tr[u].r <= r) {
		return tr[u].lca;
	}
	int mid = tr[u].l + tr[u].r >> 1;
	if(r <= mid)
		return query_lca(u << 1, l, r);
	if(l > mid)
		return query_lca(u << 1 | 1, l, r);
	int lca = query_lca(u << 1, l, r);	
	return (LCA(lca, query_lca(u << 1 | 1, l, r)));
}

ll query_ans(int u, int l, int r, int lca)
{
	if(l <= tr[u].l && tr[u].r <= r) {
		return (ll)tr[u].ans + (ll)(tr[u].r - tr[u].l + 1) * (dep[tr[u].lca] - dep[lca]);
	}
	int mid = tr[u].l + tr[u].r >> 1;
	ll ans = 0;
	if(l <= mid)
		ans += query_ans(u << 1, l, r, lca);
	if(r > mid)
		ans += query_ans(u << 1 | 1, l, r, lca);
	return ans;
}

int main()
{
    sieve();
    tree();
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++)
		scanf("%d", &a[i]);
	build(1, 1, n);
	for(int i = 1; i <= m; i++){
		int op, l, r;
		scanf("%d%d%d", &op, &l, &r);
		if(op == 1)
			modify(1, l, r);
		else {
			int lca = query_lca(1, l, r);
			ll ans = query_ans(1, l, r, lca);
			printf("%lld\n", ans);
		}
	}	
	return 0;
}
```
### CF1797 F.Li Hua and Path
前置是重构树理论……没学过的东西增加了
给你一棵 $n$ 个节点的树，我们称满足且仅满足以下两个限制中的==一个==的路径是好的
1. 路径 $(u,v)$ 中，$u$ 是路径上所有点编号最小的
2. 路径 $(u,v)$ 中，$v$ 是路径上所有点编号最大的
有 $m$ 次操作，第 $j$ 次操作会给出一个数 $k_j$，你需要把树上编号为 $k_j$ 的点和编号为 $n+j$ 的点连一条边
你需要在每次操作之前计算树上有多少条路径 $(u,v)$ 是好的

考虑优先满足两个限制，再计算路径
分别以下面两种方法构造出两棵重构树：
升序枚举节点，对于当前节点 $u$，与其相邻的所有节点 $v$ 中满足 $v<u$ 的，令 $u$ 为 $v$ 所在树的父节点
降序枚举节点，对于当前节点 $u$，与其相邻的所有节点 $v$ 中满足 $v>u$ 的，令 $u$ 为 $v$ 所在树的父节点

有性质：在第一棵树中，路径 $(u,v)$ 中的编号最大的点就是 $lca(u,v)$，在第二棵树中编号最小的点同理

考虑一下容斥，先算出所有满足限制1的路径数，所有满足限制2的路径数，再减去**两倍**所有同时满足两个限制的路径数

前两种情况用深度直接算
考虑第三种情况，第三种情况是对于路径 $(u,v)$，$u$ 在大根重构树是 $v$ 的祖先，$v$ 在小根重构树是 $u$ 的祖先，用树状数组统计答案即可

加入叶子时，一端叶子一定是编号最大的，小根重构树上统计另一端不是最大的即可