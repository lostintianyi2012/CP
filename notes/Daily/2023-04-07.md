---
aliases: 2023-04-07
tag: Daily-note
date: 2023-04-07
---
## 待办事项
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 

## 学习内容

1. 
2. 
3. 
4. 

## 日记
看了点计算寄何，怎么这么难
先做两题CF摆摆烂
然后先找点数据结构做，等下再找点图论做
再然后把计算几何的几个例题做一下，试试不看解析

## 做题记录
### CF1796D
给你一个序列 $a_1, a_2, a_3, \cdots, a_n$ 和两个数 $x$ 和 $k$
你需要给选择序列中恰好 $k$ 个不同的数，使其加上 $x$，其余位置减去 $x$
最大化序列的最大子区间和
$k\le 20$
这个就是，普通的dp吧……
先给整个序列减去 $x$，每次加 $2x$
不妨假设 $dp_{i,j}$ 表示钦定选第 $i$ 个，已经给 $j$ 个位置加上了 $2x$ 的一段极大子区间和
$$
dp_{i,j}=\max(dp_{i-1, j} + a_i,dp_{i-1, j-1}+a_i+2x)
$$
不过这题套路但是细节是真的麻烦……不看题解都写不出来
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;
typedef long long ll;
const int N = 2e5 + 10;
ll dp[22][N];
ll a[N];
int n, k;
ll x;

int main(){
	int T;
	scanf("%d", &T);
	while(T--){
		scanf("%d%d%lld", &n, &k, &x);
		for(int i = 1; i <= n; i++){
			scanf("%lld", &a[i]);
			a[i] -= x;
		}
		ll ans = 0;
		for(int i = 1; i <= n; i ++){
			dp[0][i] = max(max(dp[0][i-1] + a[i], a[i]), 0ll);
			if(i <= n - k)
				ans = max(ans, dp[0][i]);
			for(int j = 1; j <= k; j ++){
				if(i < j)
					continue;
				if(i == j)
					dp[j][i] = max(dp[j-1][i-1] + a[i] + 2 * x, 0ll);
				else
					dp[j][i] = max(max(dp[j-1][i-1] + a[i] + 2 * x, dp[j][i-1] + a[i]), 0ll);
				if(i <= n - (k - j))
					ans = max(ans, dp[j][i]);
			}
		}

		printf("%lld\n", ans);
	}
	return 0;
}

```

### P2146 软件包管理器
给你一颗初始全部为 $0$ 的树，要支持两个操作
1. 把根节点到 $x$ 的一条路径上的所有点权赋为 $1$
2. 把 $x$ 的子树内所有点权赋为 $0$ 

树剖板子不谈，不过写出了奇怪UB

### P3979
给你一颗以 $id$ 为根的树，你需要支持三种询问
1. 路径覆盖 $u$ 到 $v$ 的所有点的点权
2. 把根修改为 $id$
3. 查询所有以 $u$ 为根的子树的最小值

考虑实际上不改变整个树的结构。
假设当前整棵树的“根”是 $r$
$r$ 不在 $u$ 的子树之内，那么取 $r$ 为根的时候 $u$ 和它的子树显然不受影响
$r$ 在 $u$ 的子树之内，取 $r$ 为根的时候查询的值是整棵树中，去掉 $u$ 所的子树中 $r$ 所在子树的其余节点的信息的并
注意如果 $r$ 恰好为 $u$ 的话就是整棵树的信息并
问题在于如何快速查询一个节点是否在一棵子树内，这等价于两个节点的 LCA 是否是子树的根，直接按树链剖分的跳法直到跳到深度大于等于子树的根即可，如果两个同属一个重链，那么就在子树内，跳的时候维护一下从哪棵子树来