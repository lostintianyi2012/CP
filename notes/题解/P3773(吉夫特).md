---
aliases: P3773 吉夫特
tags: 组合计数
---
# P3773

给一个数列 $a_1, a_2, a_3,\cdots ,a_n$，问有多少个长度 $\ge 2$ 的不上升的子序列满足
$$
\prod_{i=2}^k \binom{a_{b_{i-1}}}{a_{b_i}}\equiv 1 \pmod 2
$$
其中 $b_1, b_2, b_3,\cdots , b_k$ 是子序列的下标

这等于
$$
\prod_{i=2}^k [a_{b_{i-1}}\operatorname{and} a_{b_i}=a_{b_i}]
$$
用 Lucas 定理把两个数用二进制展开就可以得到这个结论

那么每个数都是上一个数的二进制展开中，去掉若干个 $1$ 所组成的

这个限制严格强于不上升子序列，也就是说只要求序列中有多少个序列每一个位都是上一位去掉若干个 $1$ 组成的

可以用类似 $\rm {LIS}$ 的方法考虑

令 $g[i]$ 表示以 $a_i$ 结尾的子序列的数量

则有
$$
g[i]=\bigg (\sum_{j=1}^{i-1}g[j][a_j \operatorname{and} a_i=a_i]
\bigg )+ 1
$$
前面的部分是接到前面的子序列上，后面的部分是自己另开一个子序列

答案有
$$
\sum_{i=2}^n(g[i]-1)
$$
减 $1$ 是为了去掉自己独立出来的一个

$100\rm {pts}$ 就是在这个的基础上转而用刷表枚举子集即可

```cpp
#include <iostream>
#include <algorithm>
#include <string.h>
#include <algorithm>

typedef long long ll;
const int N = 2e5 + 5e4;
const ll mod = 1e9 + 7;
int a[N];
ll f[N];
int n;

char buf[1 << 20], *p1, *p2;
inline char gc(){
	if(p1 == p2){
		p2 = (p1 = buf) + fread(buf, 1, 1 << 20, stdin);
	}
	return p1 == p2 ? EOF : *p1++;
}

inline ll read(){
	ll s = 0, w = 1;
	char c = gc();
	while(!isdigit(c)){
		if(c == '-')
			w = -1;
		c = gc();
	}
	while(isdigit(c)){
		s = (s << 3) + (s << 1) + (c ^ 48);
		c = gc();
	}
	return s * w;
}

int main(){
	n = read();
	for(int i = 1; i <= n; i++)
		a[i] = read();

	ll ans = 0;
	for(int i = 1; i <= n; i++){
        //枚举a[i]的所有子集S
		for(int S = (a[i] - 1) & a[i]; S; S = (S - 1) & a[i])
			f[S] = (f[S] + f[a[i]] + 1) % mod;
        //这个时候 f[a[i]] 只有前面的数给它的贡献，相当于把原序列下标放到了时间维
		ans = (ans + f[a[i]]) % mod;
	}
	printf("%lld\n", ans);
	return 0;
}
```

