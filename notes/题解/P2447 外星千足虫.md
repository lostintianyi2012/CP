---
aliases: [SDOI2010]外星千足虫
tags: 高斯消元
type: solution
---
## 题意
有 $n$ 个正整数，给你 $m$ 次操作的结果，一次操作定义为从数列中选出若干个数之和 $\bmod 2$ 的结果，问第几次操作时可以确定每个数的奇偶性，并输出所有数的奇偶性，或是输出不能确定

## 做法
异或高斯消元
注意到在 $\bmod 2$ 意义下，每个数只有最后一个位有用
考虑这个时候的加法，容易发现和异或是一样的
把取的数系数赋为 $1$ 即可
至于要知道第 $k$ 次操作时确定答案，只要正常高斯消元，在出现解的时候就直接退出，中途存下最远到了第几行即可
```cpp
#include <iostream>
#include <string.h>
#include <bitset>
#include <algorithm>

const int N = 1e3 + 10;
char row[N];
std::bitset<N> mat[N << 1];
int n, m;
int K;

void print_matrix(){
	for(int i = 1; i <= m; i++){
		for(int j = 1; j <= n + 1; j++){
			if(mat[i][j])
				printf("1 ");
			else
				printf("0 ");
		}
		puts("");
	}
	puts("");
}

int Gauss_Jordan(){
	int line = 1;
	//m 行 n 列
	for(int i = 1; i <= n; i++){
		int maxn = line;
		for(int j = line; j <= m; j++)
			if(mat[j][i]){
				maxn = j;
				break;
			}
		//存最远的位置
		K = std::max(K, maxn);

		if(!mat[maxn][i])
			continue;

		std::swap(mat[maxn], mat[line]);
		for(int j = 1; j <= m; j++){
			if(j == line)
				continue;
			if(mat[j][i])
				mat[j] ^= mat[line];
		}
		line++;
//		print_matrix();
	}
	//无解的情况
	if(line <= n)
		return -1;
	else
		return K;
}

int main(){
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= m; i++){
		scanf("%s", row + 1);

		for(int j = 1; j <= n; j++){
			mat[i][j] = row[j] - '0';
		}
		int t;
		scanf("%d", &t);
		mat[i][n + 1] = t;
	}
//	print_matrix();
	int ans = Gauss_Jordan();
	if(ans == -1)
		puts("Cannot Determine");
	else{
		printf("%d\n", K);
		for(int i = 1; i <= n; i++){
			if(mat[i][n + 1])
				puts("?y7M#");
			else
				puts("Earth");
		}
	}
	return 0;
}

```