# NOIP 2021 提高组

## T1
这题没有什么很好的特殊做法, 只要枚举含有 $7$ 的数然后把其所有倍数全都筛掉就可以了
把所有没筛掉的放到一个数组里然后每次查询二分即可
```cpp
#include <iostream>
#include <string.h>
#include <algorithm>
#include <bitset>
#include <time.h>

using namespace std;
const int N = 1e7 + 1000;
bitset<N + 10> st;
int nxt[N];
int ans[N], idx;

bool check(int x){
    while(x){
        if(x % 10 == 7)
            return true;
        x /= 10;
    }
    return false;
}

void table_init(){
    for(int i = 1; i <= N; i++){
        if(st[i])
            continue;
        if(check(i)){
            for(int j = 1; i * j <= N; j++)
                st[i * j] = 1;
        }
    }
    for(int i = 1; i <= N; i++)
        if(!st[i])
            ans[++idx] = i;
}

int main(){
    table_init();
    int t;
    scanf("%d", &t);
    while(t--){
        int k;
        scanf("%d", &k);
        int x = lower_bound(ans + 1, ans + 1 + idx, k) - ans;
        if(ans[x] != k)
            puts("-1");
        else
            printf("%d\n", ans[x + 1]);
    }
    return 0;
}
```

## T2 数列

### 算法1($n\le 8, m\le 9$)
直接枚举 $a_i$ 的所有取值可能, 暴力计算判断合法并求权值即可
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod = 998244353;
const int N = 105;
int n, m, k, v[N], a[N];
ll ans;

int count(ll x)
{
    int res = 0;
    while (x) {
        x -= (-x & x);
        res++;
    }
    return res;
}

void dfs(int x, ll s, ll cnt)
{
    if (x >= n + 1) {
        int tmp = count(s);
        if (tmp <= k)
            ans = (ans + cnt) % mod;
        return;
    }
    for (int i = 0; i <= m; i++) {
        a[x] = i;
        dfs(x + 1, s + (1 << i), cnt * v[i] % mod);
    }
}

int main()
{
    scanf("%d%d%d", &n, &m, &k);
    for (int i = 0; i <= m; i++)
        scanf("%d", &v[i]);
    dfs(1, 0, 1);
    printf("%lld\n", ans);
    return 0;
}
```
期望得分 $20\rm {pts}$
#STL## 算法2
上面的爆搜可以记忆化一下, 设 $f[x][s]$ 是填到第 $x$ 位和为 $s$ 的答案, 时间复杂度是 $O(n^2 2^m m)$
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod = 998244353;
const int N = 105, M = 120005;
int n, m, k, v[N], a[N];
ll f[35][M];

int count(ll x)
{
    int res = 0;
    while (x) {
        x -= (-x & x);
        res++;
    }
    return res;
}

ll dfs(int x, ll s)
{
    if (x >= n + 1)
        return count(s) <= k;
    if (f[x][s] != -1)
        return f[x][s];
    long long res = 0;
    for (int i = 0; i <= m; i++) {
        a[x] = i;
        res = (res + dfs(x + 1, s + (1 << i)) * v[i] % mod) % mod;
    }
    return f[x][s] = res;
}

int main()
{
    memset(f, -1, sizeof(f));
    scanf("%d%d%d", &n, &m, &k);
    for (int i = 0; i <= m; i++)
        scanf("%d", &v[i]);
    printf("%lld\n", dfs(1, 0));
    return 0;
}
```

得分是 $50\rm {pts}$

### 算法3
既然可以记忆化搜索, 考虑DP
注意到上面时间复杂度的瓶颈在于枚举每一位的指数, 不妨考虑一次性把所有指数相同的数都加进来
因为低位的数进位会影响到高位的, 所以从低到高枚举 $S$ 的每一位
设 $dp[i][j][k]$ 表示考虑了 $S$ 的从低到高的前 $i$ 位, 有 $j$ 个数已经被加进来, 此时 $S$ 从低到高有 $k$ 个 $1$
容易发现这样进位很难考虑, 于是再增加一维 $l$ 表示要向后面的位数进 $l$ 个 $1$(先不考虑二进制的限制), 变为 $dp[i][j][k][l]$
接下来考虑转移
假设当前有 $t$ 个数是 $i$ (有 $t$ 个 $2^i$ 贡献给了 $S$)
也就是第 $i$ 位有 $t$ 个 $1$, 加上上一位向这一位有 $l$ 个 $1$, 当前有 $t+l$ 个 $1$
每两个 $1$ 可以向下一位进一个 $1$, 所以下一步状态就是
$$
dp[i+1][j+t][k+((t+l)\bmod 2)][\lfloor \frac{t+l}{2}\rfloor]
$$
考虑这一步的贡献, 选了 $t$ 个 $v_i$, 一共有 $\binom{n-j}{n}$ 种选法, 贡献即为
$$
v_i^t\times \binom{n-j}{n}
$$
也就是
$$
dp[i+1][j+t][k+((t+p)\bmod 2)][\lfloor \frac{t+p}{2}\rfloor]=dp[i][j][k][l]\times v_i^t\times \binom{n-j}{n}
$$
预处理一下组合数, 记忆化搜索即可
```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
const int mod = 998244353;
const int N = 40;
const int M = 110;
inline int read()
{
    int x = 0, f = 1;
    char c = getchar();
    while (!isdigit(c)) {
        if (c == '-')
            f = -1;
        c = getchar();
    }
    while (isdigit(c)) {
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}

int n, m, i, j, k;
int C[M][M], s[M][M];
int f[M][N][N][N], v[M], K;

int count(int x)
{
    int ans = 0;
    while (x)
        x -= x & -x, ++ans;
    return ans;
}

int dfs(int k, int u, int x, int y)
{
    if (u == n) {
        if (x + count(y) > K)
            return 0;
        return 1;
    }
    if (k > m)
        return 0;
    if (f[k][u][x][y] != -1)
        return f[k][u][x][y];
    int ans = 0;
    for (int i = 0; i <= n - u; ++i) {
        //记忆化搜索, 就是上面的递推式子
        ans = (ans + dfs(k + 1, u + i, x + ((y + i) & 1), (y + i) >> 1) * s[k][i] % mod * C[u + i][i] % mod) % mod;
    }
    f[k][u][x][y] = ans;
    return f[k][u][x][y];
}

signed main()
{
    memset(f, -1, sizeof(f));
    n = read();
    m = read();
    K = read();
    for (i = 0; i <= m; ++i)
        v[i] = read();
    C[0][0] = 1;
    for (i = 1; i <= n; ++i)
        for (j = C[i][0] = 1; j <= i; ++j)
            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
    for (i = 0; i <= m; ++i) {
        s[i][0] = 1;
        for (j = 1; j <= n; ++j)
            s[i][j] = (s[i][j - 1] * v[i]) % mod;
    }
    printf("%lld\n", dfs(0, 0, 0, 0));
    return 0;
}
```

## T3 方差
答案要求的式子是
$$
n\sum_{i=1}^{n}a_i^2-(\sum_{i=1}^{n}a_i)^2
$$
观察题目的限制条件, 注意到无论如何数列一定保持**单调递增**
然后考虑题目的特殊变换:
$$
a_i = a_{i-1}+a_{i+1} - a_i
$$
如果我们假设 $a_i'$ 是变化后的 $a_i$
那么
$$
a'_i - a_{i-1} = a_{i+1} - a_i\\
a_{i+1} - a'_i = a_i - a{i-1}
$$
实质上对 $i$ 做变换就是交换 $a_i$ 和 $a_{i+1}$ 的差分数组
由于对变换次数没有限制, 所以通过若干次变换任何一个差分数组的排列都可以被列出来, 所以这个时候一个 $O(n!)$ 的做法就显然了:
### 算法一 
直接暴力枚举所有可能的差分数组排列, 求方差最小值
这个做法期望能拿到前三个点的分

### 算法二
$n$ 很小, 并且注意到"交换"这一个操作实际上是对方差进行调整
调整？调整！随机调整！
随机调整通常能跑出不是很差的解, 直接用模拟退火, 每次都随机交换差分数组中两个数的值再校验
同时考虑方差的实际意义是数据的偏离程度, 可以构造出一个差分先减后增的序列, 这可以让答案更加集中

### 算法三
从算法二可以看出来最好的情况必然是差分先减后增(单谷), 但是每个差分值在左侧或是右侧还需要讨论, 把差分数组从小到大排序, 每个数要么插在新序列的左边, 要么插在新序列的右边
所以就可以考虑DP算插每个数的时候的值了, 发现变化量的值不好维护, 和新的序列的和相关, 所以可以把新的序列和也放到状态里
设 $f[i][x]$ 表示考虑完前 $i$ 个数, 所有 $a$ 的和为 $x$ 的时候的最小平方和
再把题目所求写一遍：
$$
n\sum_{i=1}^{n}a_i^2-(\sum_{i=1}^{n}a_i)^2
$$
发现右式和恒定, DP左侧即可
如果第 $i$ 个数插入到左边, 那么
$$
f[i+1][x+i\times d_i]=f[i][x]+2\times x\times d_i +i\times d_i^2
$$
这是因为如果把 $d_i$ 插入到左侧, 那么原先的 $1\sim i$ 的 $a'_k$(新的序列) 都增加了 $d_i$, 原先的 $(a'_k)^2$ 变为 $(a'_k+d_i)^2$, 每一个对答案的新增的贡献都是 $2\times a'_k \times d_i + d_i^2$
如果第 $i$ 个数插入到右边, 那么
$$
f[i+1][x+a'_i]=f[i][x]+(a'_i)^2
$$
边界条件另 $f[1][0] = 0$ 即可
答案就是
$$
\min_{s=0}^{\max x}\{n\times f[n][s] + s^2\}
$$
时间复杂度为 $O(n^2a)$, 滚动数组优化一下, 空间复杂度为 $O(na)$ 
仍然是 $80\rm {pts}$, 但是这个解法比算法二有前途得多, 只差一步优化
### 算法四
注意到最后的点 $n$ 大而 $a$ 小, 考虑把一个 $n$ 变成 $a$
实际上, 由于 $\min(n,a)$ 不大, 所以可能有不少的 $d_i=0$(至多$\max a_i$ 个不为 $0$, 单调递增带来的), 这个时候不会有转移, 可以跳过
复杂度降低为 $O(\min(n,a)na)$, 期望 $100\rm {pts}$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

ll read()
{
    ll w = 1, s = 0;
    char c = getchar();
    while (!isdigit(c)) {
        if (c == '-')
            w = -1;
        c = getchar();
    }
    while (isdigit(c)) {
        s = (s << 3) + (s << 1) + (c ^ 48);
        c = getchar();
    }
    return s * w;
}

const ll inf = 1e18;
const int M = 1e4 + 10;
ll n, a[M], b[M], sum[M], dp[2][M * 55], ans = inf;

int main()
{
    n = read();
    for (int i = 1; i <= n; i++)
        a[i] = read();
    for (int i = 1; i < n; i++)
        b[i] = a[i + 1] - a[i];
    sort(b + 1, b + n);

    int cnt = 0;
    for (int i = 1; i < n; i++)
        if (b[i] == 0)
            cnt++;

    for (int i = 1; i < n; i++)
        sum[i] = sum[i - 1] + b[i];
    ll maxn = a[n];

    for (int i = 1; i <= maxn * n; i++)
        dp[cnt & 1][i] = inf;

    //只有d_i不为0的才要考虑
    for (int i = cnt + 1; i < n; i++) {
        for (int j = 0; j <= maxn * n; j++)
            dp[i & 1][j] = inf;

        for (ll j = 0; j <= maxn * n; j++) {
            if (dp[(i & 1) ^ 1][j] == inf)
                continue;
            dp[i & 1][j + sum[i]] = min(dp[i & 1][j + sum[i]], dp[(i & 1) ^ 1][j] + sum[i] * sum[i]);
            dp[i & 1][j + b[i] * i] = min(dp[i & 1][j + b[i] * i], dp[(i & 1) ^ 1][j] + j * 2 * b[i] + b[i] * b[i] * i);
        }
    }

    for (ll i = 0; i <= maxn * (n - 1); i++)
        if (dp[(n & 1) ^ 1][i] != inf)
            ans = min(ans, n * dp[(n & 1) ^ 1][i] - i * i);

    cout << ans << endl;
    return 0;
}
```