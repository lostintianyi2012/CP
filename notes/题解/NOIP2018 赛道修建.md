# NOIP2018 赛道修建

给定一个 $n$ 个节点的树, 要求选出 $m$ 条不重复的路径, 使得选出路径中长度最小的长度尽可能大

### 算法1
暴力 DFS 枚举路径即可, 期望通过前三个点

### 特殊性质下的做法
**特殊性质 A: $m=1$**
只要在树上找到一条最长的路径即可, 树形DP一下

**特殊性质 B: $a_i=1$**
一个菊花, 二分答案, 假设二分出的答案是 $tmp$, 对于每条边取出 $\ge tmp-l$ 的最小值

**特殊性质 C: $b_i=a_i+1$**
树是一条链, 问题变成给你一个序列划分为 $m$ 段, 使最小的段和最大
显然**二分答案即可**

**特殊性质 D: 节点度数$\le 3$**
该性质表明这是个二叉树
尝试把特殊性质 C 的做法推广到二叉树上, 设每次二分出的答案为 $tmp$
自底向上计算, 对每个节点 $u$ 维护 $lc[u]$, $rc[u]$, 分别表示左,右子树向下延伸出的一条不属于答案的链的长度, 如果 $lc[u]/rc[u] \ge tmp$ 那么令 $lc[u]/rc[u]=0$ 且 $ans+1$
第二种情况是 $lc[u]+rc[u]\ge tmp$, 这个时候令 $lc[u]=rc[u]=0$ 且 $ans+1$ 即可

## 算法2
根据上面对特殊性质的分析, 把特殊性质 B 和 D 的做法结合一下即可, 对于每个节点维护它所有子树伸出的链, 链长 $\ge tmp$ 的做法不变, 另一种情况枚举每一条链, 对于每一条链, 取一条 $\ge tmp - l$ 的最小值即可, 要取一个最大的上传, 用multiset 维护
时间复杂度 $O(n \log n \log v)$
```cpp
#include <iostream>
#include <string.h>
#include <stdio.h>
#include <vector>
#include <algorithm>
#include <set>

using namespace std;
const int N = 5e4 + 10, M = 1e5 + 10;
int h[N], e[M], ne[M], w[M], idx;
multiset<int> f[N];
int n, m;
int lim;
int chain_num;

void add(int u, int v, int c){
    e[idx] = v, ne[idx] = h[u], w[idx] = c, h[u] = idx++;
}

//dfs表示求出当前的限制之下最多能开出几条链

int dfs(int u, int fa){
    int maxn = 0;
    f[u].clear();
    int k;
    for(int i = h[u]; ~i; i = ne[i]){
        int v = e[i];
        if(v == fa)
            continue;
        k = dfs(v, u) + w[i];
        if(k >= lim)
            chain_num++;
        else{
            f[u].insert(k);
        }
    }
    multiset<int>::iterator it;
    while(!f[u].empty()){
        if(f[u].size() == 1)
            return max(maxn, *f[u].begin());
        it = f[u].lower_bound(lim - *f[u].begin());

        if(it == f[u].begin() && f[u].count(*it) == 1)
            it++;
        if(it == f[u].end()){
            maxn = max(maxn, *f[u].begin());
            f[u].erase(f[u].find(*f[u].begin()));
        }
        else{
            chain_num++;
            f[u].erase(f[u].find(*f[u].begin()));
            f[u].erase(f[u].find(*it));
        }
    }
    return maxn;
}

bool check(int x){
    lim = x;
    chain_num = 0;
    dfs(1, -1);
    return chain_num >= m;
}

int main(){
    memset(h, -1, sizeof h);
    scanf("%d%d", &n, &m);
    int sumc = 0;
    for(int i = 1; i < n; i++){
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c), add(b, a, c);
        sumc += c;
    }

    int l = 1, r = sumc + 100000;
    int ans = 0;
    while(l < r){
        int mid = (l + r) >> 1;
        if(check(mid))  {ans = mid, l = mid + 1;}
        else    r = mid;
    }
    printf("%d\n", ans);
    return 0;
}
```