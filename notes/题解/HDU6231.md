---
author: lsty
title: HDU6231 题解
type: Solution
tags: 双指针, Educational
---
# HDU 6231
## 简明题意
给定一个序列 $A$ , 将其所有长度 $\ge k$ 的子区间的第 $k$ 大加入序列 $B$ , 求序列 $B$ 的第 $m$ 大

## 思路
首先显然不能暴力维护,既然不知道序列 $B$ , 那么不可能直接找到第 $m$ 大

反过来,我们可以考虑给定一个数,如何找到它在 $B$ 中的排名

也就是说 $B$ 中, $x$ 之前有多少个数, 问题转化为有多少个子序列的 $kth\ge x$

把原 $A$ 中所有大于等于 $x$ 的数都变成 $1$, 其余全部变成 $0$

这样如果一个子区间中所有元素和 $\ge k$, 就说明至少有 $k$ 个大于等于 $x$ 的数, 也就是该区间对 $B$ 贡献的数 $\ge x$, 排在 $x$ 之前

对这样的子区间计数,即可知道 $B$ 中 $x$ 之前有多少个数

计数可以使用尺取法,对于每个端点找到最小的右端点使得 $s[l,r] \ge k$, 那么这个左端点就有 $n-r+1$ 个对应的区间合法

$O(n \log n)$

## 代码
```cpp
#include <bits/stdc++.h>

using namespace std;
const int N = 1e5 + 10;
int a[N], b[N];
int sum[N];
int n, k;
long long m;

inline bool check(int x){
    long long res = 0;
    for(int i = 1; i <= n; i++){
        sum[i] = sum[i-1];
        if(a[i] >= x){
            sum[i] ++;
        }
    }

    for(int i = 1, j = 1; i <= n && j <= n; i ++){
        while(sum[j] - sum[i-1] < k && j <= n)    j++;
        res += n - j + 1;
    }
    return res >= m;
}

int main(){
    int T;
    scanf("%d", &T);

    while(T--){
        scanf("%d%d%lld", &n, &k, &m);
        for(int i = 1; i <= n; i ++){
            scanf("%d", &a[i]);
            b[i] = a[i];
        }
        sort(b + 1, b + n +1);

        int l = 1, r = n+1, ans;
        while(l < r){
            int mid = (l + r) >> 1;
            if(check(b[mid]))  { ans = mid, l = mid + 1;}
            else    r = mid;
        }

        printf("%d\n", b[ans]);
    }
    return 0;
}
```