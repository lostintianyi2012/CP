# CSP 2022 提高组

## T1 旅行计划
### 算法1
测试点 $1\sim 8$ 满足 $n\le 30$, 可以直接枚举 $A, B, C, D$ 四个点, 时间复杂度 $O(n^4)$, 期望得分 $40\rm {pts}$

### 算法2
考虑减少枚举的点的数量, 如果 $A, B, C$ 已经确定, 那么 $D$ 就可以不用枚举了, 直接取在 $C$ 的 $k$ 步之内并且在 $1$ 的 $k$ 步之内并且==没有被取过==的最大值(通过预处理一个点可达并且从 $1$ 可达的前三大)即可, 这一步需要预处理出每个点到其他所有点的距离, 因为没有边权所以可以 $O(N^2)$ 解决, 时间复杂度 $O(n^3)$, 期望得分 $70\rm {pts}$

### 算法3
可以发现, 只要 $C$ 点固定了 $D$ 点就是固定的, 所以考虑用同样的方法维护 $A$ 点, 只要 $B$ 固定了 $A$ 同样是固定的, 类似上面即可, 时间复杂度 $O(n^2)$, 期望得分 $100\rm {pts}$

```cpp
#include <bits/stdc++.h>

using namespace std;
const int N = 2510, M = 2e4 + 10;
const int inf = 0x3f3f3f3f;
typedef pair<long long, int> PII;
int e[M], ne[M], h[N], G[N][N], idx;
long long w[N];
PII f[N][3];
bool st[N];
int n, m, k;

inline void add(int a, int b){
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
    e[idx] = a, ne[idx] = h[b], h[b] = idx++;
}

bool cmp(PII a, PII b){
    return a.first > b.first;
}

void bfs(int z){
    queue<int> q;
    q.push(z);
    G[z][z] = -1;
    while(!q.empty()){
        int u = q.front();
        q.pop();
        for(int i = h[u]; ~i; i = ne[i]){
            int v = e[i];
            if(G[z][v] != inf)
                continue;
            
            G[z][v] = G[z][u] + 1;
            q.push(v);

            //如果这个点在家附近并且从这个点出发可以到达
            if(st[v] && G[z][v] <= k){
                PII tmp[4];
                for(int i = 0; i < 3; i++)
                    tmp[i] = f[z][i];
                tmp[3].first = w[v];
                tmp[3].second = v;
                sort(tmp, tmp + 4, cmp);
                for(int i = 0; i < 3; i++)
                    f[z][i] = tmp[i];
            }
        }
    }
    
}

int main(){
    memset(h, -1, sizeof h);
    memset(G, 0x3f, sizeof G);
    scanf("%d%d%d", &n, &m, &k);
    for(int i = 2; i <= n; i++){
        scanf("%lld", &w[i]);
    }
    for(int i = 1; i <= m; i++){
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b);
    }
    for(int i = 1; i <= n; i++){
        for(int j = 0; j < 3; j++)
            f[i][j] = {-1, 0};
    }
    
    st[1] = false;
    queue<int> q;
    q.push(1);
    G[1][1] = -1;
    while(!q.empty()){
        int u = q.front();
        q.pop();
        for(int i = h[u]; ~i; i = ne[i]){
            int v = e[i];
            if(G[1][v] != inf)
                continue;

            G[1][v] = G[1][u] + 1;
            q.push(v);

            if(G[1][v] <= k)
                st[v] = true;
        }
    }

    for(int i = 2; i <= n; i++){
        bfs(i);
    }
    
    long long ans = -1;
    for(int b = 2; b <= n; b++){
        for(int c = 2; c <= n; c++){
            if(G[b][c] > k || b == c)
                continue;
            for(int i = 0; i < 3; i++){
                int a = f[b][i].second;
                if(a == 0) 
                    break;
                for(int j = 0; j < 3; j++){
                    int d = f[c][j].second;
                    if(d == 0)
                        break;
                    if(d == a || b == c || a == c || d == b)
                        continue;
                    ans = max(ans, w[a] + w[b] + w[c] + w[d]);
                }
            }
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```

## T2 策略游戏
分类讨论题, 可以直接考虑正解
由于 A 决策会考虑 B 的决策, 所以先考虑 B
如果 $x\ge 0$, B 选择最小的 $y$
否则, B 选择最大的 $y$
A的行为如下:
1. 如果 A 要让 $x\ge 0$, B 则选择最小的 $y$
这个时候如果 $y\ge 0$, A 选择最大的 $x$, 否则选最小的 $x$
2. 如果 A 要让 $x<0$, 如果 $y\ge 0$, A 选择最大的负数 $x$, 否则选择最小的正数 $x$

这四种情况取 $max$ 即可, 问题变成对于每个区间维护最大值, 最小值, 非正数最大值, 非负数最小值, 用ST表或者线段树维护都可以
```cpp
#include <bits/stdc++.h>
typedef long long ll;
inline ll read()
{
    ll x = 0;
    bool f = true;
    char ch = getchar();
    for (; !isdigit(ch); ch = getchar())
        if (ch == '-')
            f = false;
    for (; isdigit(ch); ch = getchar())
        x = (x << 1) + (x << 3) + ch - '0';
    return f ? x : (~(x - 1));
}

inline bool gmx(ll& a, ll b)
{
    return b > a ? a = b, true : false;
}

const int maxn = 1e5 + 5;
const int maxm = 1e5 + 5;
const int mlgn = 25;
const int mlgm = 25;

ll amx[maxn][mlgn], amn[maxn][mlgn], negmx[maxn][mlgn], posmn[maxn][mlgn];
ll bmx[maxm][mlgm], bmn[maxm][mlgm];

ll lg[maxn];

const ll maxinf = 0x7f7f7f7f7f7f7f7f, mininf = -0x7f7f7f7f7f7f7f7f;

signed main()
{
    int n = read(), m = read(), q = read();
    for (int i = 1; i <= n; ++i) {
        int x = read();
        amx[i][0] = amn[i][0] = x;
        negmx[i][0] = (x < 0 ? x : mininf);
        posmn[i][0] = (x >= 0 ? x : maxinf);
    }

    for (int i = 1; i <= m; ++i) {
        int x = read();
        bmx[i][0] = bmn[i][0] = x;
    }

    for (int i = 2; i <= std::max(n, m); ++i)
        lg[i] = lg[i >> 1] + 1;

    for (int j = 1; j <= lg[n]; ++j) {
        for (int i = 1; i + (1 << j) - 1 <= n; ++i) {
            int p = i + (1 << (j - 1));
            amx[i][j] = std::max(amx[i][j - 1], amx[p][j - 1]);
            negmx[i][j] = std::max(negmx[i][j - 1], negmx[p][j - 1]);
            amn[i][j] = std::min(amn[i][j - 1], amn[p][j - 1]);
            posmn[i][j] = std::min(posmn[i][j - 1], posmn[p][j - 1]);
        }
    }

    for (int j = 1; j <= lg[m]; ++j) {
        for (int i = 1; i + (1 << j) - 1 <= m; ++i) {
            int p = i + (1 << (j - 1));
            bmx[i][j] = std::max(bmx[i][j - 1], bmx[p][j - 1]);
            bmn[i][j] = std::min(bmn[i][j - 1], bmn[p][j - 1]);
        }
    }

    while (q--) {
        ll la = read(), ra = read(), lb = read(), rb = read();
        ll sa = lg[ra - la + 1], sb = lg[rb - lb + 1];
        ll pa = ra - (1 << sa) + 1, pb = rb - (1 << sb) + 1;

        ll amax = std::max(amx[la][sa], amx[pa][sa]);
        ll amin = std::min(amn[la][sa], amn[pa][sa]);
        ll afmx = std::max(negmx[la][sa], negmx[pa][sa]);
        ll azmn = std::min(posmn[la][sa], posmn[pa][sa]);
        ll bmax = std::max(bmx[lb][sb], bmx[pb][sb]);
        ll bmin = std::min(bmn[lb][sb], bmn[pb][sb]);

        ll ans = mininf;

        gmx(ans, amax * (amax >= 0 ? bmin : bmax));
        gmx(ans, amin * (amin >= 0 ? bmin : bmax));
        if (afmx != mininf)
            gmx(ans, afmx * (afmx >= 0 ? bmin : bmax));
        if (azmn != maxinf)
            gmx(ans, azmn * (azmn >= 0 ? bmin : bmax));
        printf("%lld\n", ans);
    }
    return 0;
}
```
## T3 星战

### 暴力一:
实际上只要暴力模拟题目中的操作, 每次做完暴力判环

### 暴力二:
暴力模拟题目中的操作, 题目中"反击"的条件等价于所有点出度为 $1$ 只要同时维护出度就可以得到 $40\rm {pts}$

### 正解
题目中的所有操作都是都是对"指向某一个点"的边进行的, 容易想到维护每个点的入度比维护每个点的出度更好做, 但是有一个问题在于$入度=n$不一定有$每个点出度为1$
考察$入度=n$而$存在点出度不为1$的情况, 发现这个时候有的点的出度分配给了其他点, 但是由于==每个节点每1入度的地位相等, 最后给答案的贡献没有变==, 所以只单纯看入度没有办法判断是否满足条件
既然每个节点每$1$入度的地位相等, 那就想办法让每个节点的入度给答案的贡献带权, 从而给答案的贡献不相等
对于每个节点可以随机一个权值 $k$, 表示该节点每有 $1$ 入度给答案的贡献就为 $k$, 最终达成局面的条件是所有点的贡献之和 $=\sum_{i=1}^n k_i$
```cpp
#include <iostream>
#include <time.h>
#include <string.h>
#include <algorithm>
#include <random>

using namespace std;

const int N = 5e5 + 10;
std::mt19937 rnd(time(0));
int hash_weight[N];
long long val[N];
long long all;
long long first[N];
long long dynamic;
int n, m, q;

int main(){
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++){
        hash_weight[i] = rnd();
    }

    for(int i = 1; i <= n; i++)
        all += hash_weight[i];

    for(int i = 1; i <= m; i++){
        int u, v;
        scanf("%d%d", &u, &v);
        val[v] += hash_weight[u];
        first[v] = val[v];
        dynamic += hash_weight[u];
    }

    scanf("%d", &q);
    while(q--){
        int op;
        scanf("%d", &op);
        if(op == 1){
            int u, v;
            scanf("%d%d", &u, &v);
            val[v] -= hash_weight[u];
            dynamic -= hash_weight[u];
        }
        if(op == 2){
            int u;
            scanf("%d", &u);
            dynamic -= val[u];
            val[u] = 0;
        }
        if(op == 3){
            int u, v;
            scanf("%d%d", &u, &v);
            val[v] += hash_weight[u];
            dynamic += hash_weight[u];
        }
        if(op == 4){
            int u;
            scanf("%d", &u);
            dynamic += first[u] - val[u];
            val[u] = first[u];
        }
        if(dynamic == all)
            puts("YES");
        else
            puts("NO");
    }
    return 0;
}
```