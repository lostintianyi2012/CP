定义一个SAM是接受字符串 $s$ 所有后缀的**最小DFA**
如果不了解DFA，参见[[确定性有限状态自动机]]

记 $t_0$ 为初始状态，则SAM上的任何一个从 $t_0$ 出发的路径上，按顺序记下转移路径上的标号，则其为一个 $s$ 的子串，反过来任何一个 $s$ 的子串也对应SAM上的一条路径

### 构造SAM
如果字符集大小 $|\Sigma|$ 是一个常数，SAM的构造可以做到线性时空复杂度，但在介绍构造前需要先引入两个重要的概念

#### endpos等价类
设 $t$ 为 $s$ 的一个非空子串，那么记 $t$ 在 $s$ 中所有结束位置组成的集合为endpos(t)
两个子串 $t_1, t_2$ 的endpos集合可能是相等的，记为endpos($t_1$)=endpos($t_2$)，接下来把endpos相等的子串记为一类，称为==endpos等价类==
那么不难发现按照这样的划分方式，SAM中的状态对应一个或多个endpos的子串，SAM中节点的个数就是endpos等价类的个数加初始节点
>引理1:
>$s$ 的两个非空子串 $u$ 和 $w$ (假设 $|u|\le |w|$) 是一个endpos等价类，当且仅当 $u$ 每次在 $s$ 中都以 $w$ 的后缀形式出现

考虑定义，这显然成立
>引理2:
>$s$ 的两个非空子串 $u$ 和 $w$ (假设 $|u|\le |w|$) 若有 $u$ 是 $w$ 的后缀则 endpos($w$) 是 endpos($u$) 的子集，否则 endpos($u$) 与 endpos($w$) 交为空集

仍然显然成立，由于 $u$ 是 $w$ 的后缀，则每次 $w$ 出现 $u$ 都出现，反之却不成立

>引理3:
>对于一个endpos等价类，所有较短的子串一定是较长子串的后缀，且若记 $u$ 和 $w$ 分别为最短和最长的子串，则在 $[|u|, |w|]$ 之间的每个长度都有一个子串对应

由引理1，endpos等价的字符串中较短者一定是较长者的后缀，所以不会有等长的字符串
考虑长度在 $[|u|,|w|]$ 之间的 $w$ 的任意后缀，该子串只能以 $w$ 的后缀形式出现，所以由引理1，该后缀也在等价类中

#### 后缀链接树
由上面的三条引理，可以看出endpos等价类之间有着非常好的集合之间的包含关系，不难想到用子集的关系构建一个树形的结构
考虑一个不是 $t_0$ 的状态 $v$，其对应一个具有相同endpos的等价类，由引理3可得等价类中有一段长度连续的后缀，而小于这些长度的后缀（这里包含空后缀）在其他等价类中，记 $t$ 为这些其他等价类中的后缀最长的，则令 $v$ 的后缀链接连接到 $t$ 所属的等价类的节点
假设根节点（空串）的endpos集合是 $\{1, 2, \cdots, |S|\}$
则
>引理4:
>所有后缀链接构成一棵以 $t_0$ 为根的树

后缀链接的定义使得我们每次沿后缀链接走，总能走到严格更短的字符串，最后一定能到 $t_0$
>引理5:
>后缀链接树与endpos树相同

证明：由引理 2，任意一个 SAM 的 $\operatorname{endpos}$ 集合形成了一棵树（因为两个集合要么完全没有交集要么其中一个是另一个的子集）。
我们现在考虑任意不是 $t_0$ 的状态 $v$ 及后缀链接 $\operatorname{link}(v)$，由后缀链接和引理 2，我们可以得到
$$
\operatorname{endpos}(v)\subsetneq \operatorname{endpos}(\operatorname{link}(v)),
$$
注意这里应该是 $\subsetneq$ 而不是 $\subseteq$，因为若 $\operatorname{endpos}(v)=\operatorname{endpos}(\operatorname{link}(v))$，那么 $v$ 和 $\operatorname{link}(v)$ 应该被合并为一个节点
结合前面的引理有：后缀链接构成的树本质上是 $\operatorname{endpos}$ 集合构成的一棵树。

#### SAM的构造
SAM的构造采用增量构造法，每次新加入一个字符，并把产生的所有新后缀全部加入SAM中
令包含原串后缀的节点称为“终止节点”，也就是endpos有 $n$ 的节点
每次新产生的后缀都是从后面新加一个字符，构造自然利用终止节点构造
令 $last$ 表示上一次原串被包含的节点，$cur$ 为当前新建的节点， $c$ 为当前要加入的字符，$len(v)$ 表示节点 $v$ 表示的endpos等价类中最长的子串长度，$link(v)$ 表示节点 $v$ 的后缀链接，$next(v,c)$ 表示节点 $v$ 经过边 $c$ 
由后缀链接的定义，$len(cur)=len(last)+1$
接下来只要一直回溯后缀链接，找到原来的所有后缀，再连一条当前字符的边到 $cur$，把路上所有的节点 $v$ 设置 $next(v, c)=cur$
```cpp
```
如果最后跳转到原点，设置 $link(cur)=t_0$ 即可，这说明没有其他endpos等价类包含所有产生的新后缀（这个字符第一次加入）
反之如果没有到原点，某个点已经包含了要加入的后缀，那么这个后缀不能被加入两次，现在令这个包含后缀的节点是 $p$，$q=next(p, c)$，$p$ 表示的字符串为 $x$，则我们希望加入的是 $x+c$ 但其已经被 $q$ 表示了，问题在于 $cur$ 的 $link$ 应该指向哪个节点
1. 如果 $len(q)=len(p)+1$ 则 $link(cur)=q$ 
这代表当前这个点没有比新后缀更长的串，可以直接链接
2. 如果 $len(q) > len(p)+1$
考虑把 $q$ 分裂，一部分比新后缀长，一部分比新后缀等长或更短
先构造一个 $q$ 的 $clone$
然后把 $q$ 所有边连到 $clone$ 上
$clone$ 是小于等于的新点
设置
$link(clone)=link(q),len(clone)=len(p)+1$
满足条件
再令 $link(cur)=clone,link(q)=clone$
把所有连接到 $q$ 的改成链接 $cur$
最后，$last=cur$